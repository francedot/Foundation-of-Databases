--CI VUOLE UNA TRANSIZIONE PER L'INSERIMENTO DI UN ISTANZA DI E3!


--SE TIPO23 A CUI SI REFERENZIA LA TUPLA INSERITA TRAMITE K1
--E' 2, ALLORA D E TT GLI ALTRI VAL DEVONO ESSERE NULLI,
--ALTRIMENTI D DEVE ESSERE NON NULLO!(NULLA POSSO DIRE SUGLI ALTRI VAL)

SELECT NAME
FROM SYSIBM.SYSTRIGGERS
WHERE SCHEMA = '09050944';

DROP TRIGGER E3_NOTNULL;

CREATE TRIGGER E3_NOTNULL
NO CASCADE BEFORE INSERT ON E3
REFERENCING NEW AS N
FOR EACH ROW
WHEN (EXISTS(SELECT *
			 FROM E1
			 WHERE N.K1 = E1.K1
			 AND E1.TIPO23 = 2
			 AND N.D IS NOT NULL
			 AND N.E IS NOT NULL
			 AND N.K1R IS NOT NULL))
SIGNAL SQLSTATE '70001' ('La tupla inserita è un istanza di E2!');

BASTA SOLO UN TRIGGER PER GARANTIRE CHE AD OGNI INSERIMENTO
IN E3 SI INSERISCA UNA TUPLA CHE SIA EFFETTIVAMENTE DI E3.
POICHE' UN ISTANZA DI E3 SI INSERISCE IN UNA TRANSIZIONE DI
INSERT PRIMA SU E1 E POI SU E3
BISOGNA DIRE CHE ALL' INSERIMENTO IN E3 LA FKEY K1 REFERENZI
STRETTAMENTE UN ISTANZA DI E1 CON TIPO = 3 CHE LA IDENTIFICA
ANCHE ESTERNAMENTE!!!

DROP TRIGGER E3_NULL;

CREATE TRIGGER E3_NULL
NO CASCADE BEFORE INSERT ON E3
REFERENCING NEW AS N
FOR EACH ROW
WHEN (EXISTS(SELECT *
			 FROM E1
			 WHERE N.K1 = E1.K1
			 AND E1.TIPO23 = 3
			 AND N.D IS NULL))
SIGNAL SQLSTATE '70002' ('La tupla inserita è un istanza di E3!');

--d) un'istanza di E3 non è mai associata, tramite R, a se
--stessa;

-- DROP TRIGGER PUNTO_D;

-- CREATE TRIGGER PUNTO_D
-- NO CASCADE BEFORE INSERT ON E3
-- REFERENCING NEW AS N
-- FOR EACH ROW
-- WHEN (EXISTS(SELECT *
			 -- FROM E3
			 -- WHERE N.K1R = E3.K1))
-- SIGNAL SQLSTATE '70003' ('Un istanza di E3 non è mai associata tramite
						  -- R a se stessa!');
--BASTA UN NORMALE CHECK PER GATANTIRE CHE K1R SIA DIVERSO DA K1 ALL' INSERIMENTO!














